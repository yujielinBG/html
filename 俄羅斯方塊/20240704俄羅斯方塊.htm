<html lang="en">
	<head>
	    <title>俄羅斯方塊</title>
		<meta charset="UTF-8">
		<style>
			canvas { border: 1px solid #000; }
		</style>
	</head>
	<body>
		<canvas id="_Canvas" width="250" height="500"></canvas>
<!--		
		<img id="w0625" src="./0625.png" alt="Source Image" style="display:none;" >
		
		<img id="select" src="./select.png" alt="Source Image" style="display:none;" >
		
		<img id="left" src="./left.png" alt="Source Image" style="display:none;" >
		
		<img id="right" src="./right.png" alt="Source Image" style="display:none;" >
-->		
	</body>
</html>


<!--
=======================================================
   Script
=======================================================
-->
<script>

let cellWidth = 25;
let width = 10;
let height = 20;

let matrix = [];

const canvas = document.getElementById('_Canvas');
const ctx = canvas.getContext('2d');	

function clean(){
    ctx.fillStyle = 'white';
    ctx.fillRect( 0 , 0 , width*cellWidth , height*cellWidth );
}

function drawBackground(){

    ctx.beginPath();
    ctx.strokeStyle = 'gray'; 
    ctx.lineWidth = 1 ; 

    for( let i= 0 ;i <= width ;i++ ){
        ctx.moveTo(i*cellWidth, 0);  
        ctx.lineTo(i*cellWidth, height*cellWidth); 
    }
    for( let j= 0 ;j <= height ;j++ ){
        ctx.moveTo(0, j*cellWidth);  
        ctx.lineTo(width*cellWidth, j*cellWidth); 
    }

    ctx.stroke();

}

class Shape {
    name = "" ; //I, L
    pictures = [] ;  
    row = 0;
    col = 0;
    index = 0;

    constructor( name ) {
        this.name = name ;
    }

    moveRight(){
        this.col++;
    }
    moveLeft(){
        this.col--;
    }
    moveDown(){
        this.row++;
    }
    rotation(){
        if ( ++this.index >= this.pictures.length ) {
            this.index = 0 ;
        }
    }
    draw(){
        ctx.fillStyle = 'black';
        for( let i=0; i<this.pictures[this.index].length; i++ ) {
            let newCol = this.col+this.pictures[this.index][i].col ;
            let newRow = this.row+this.pictures[this.index][i].row ;
            ctx.fillRect(newCol*cellWidth, newRow*cellWidth, cellWidth, cellWidth)
        }
    }

}

class Point {
    row = 0;
    col = 0;
    constructor( row, col ) {
        this.row = row ;
        this.col = col ;
    }
}

let shapeI = new Shape("I") ;
let ary = [] ;
ary[ary.length] = new Point( 0, 4 ) ;
ary[ary.length] = new Point( 1, 4 ) ;
ary[ary.length] = new Point( 2, 4 ) ;
ary[ary.length] = new Point( 3, 4 ) ;
shapeI.pictures[0] = ary  ;

ary = [] ;
ary[ary.length] = new Point( 0, 3 ) ;
ary[ary.length] = new Point( 0, 4 ) ;
ary[ary.length] = new Point( 0, 5 ) ;
ary[ary.length] = new Point( 0, 6 ) ;
shapeI.pictures[1] = ary  ;

console.log(shapeI);


let shapeJ = new Shape("J") ;
ary = [] ;
ary[ary.length] = new Point( 0, 5 ) ;
ary[ary.length] = new Point( 1, 5 ) ;
ary[ary.length] = new Point( 2, 5 ) ;
ary[ary.length] = new Point( 2, 4 ) ;
shapeJ.pictures[0] = ary  ;

ary = [] ;
ary[ary.length] = new Point( 0, 4 ) ;
ary[ary.length] = new Point( 1, 4 ) ;
ary[ary.length] = new Point( 1, 5 ) ;
ary[ary.length] = new Point( 1, 6 ) ;
shapeJ.pictures[1] = ary  ;

ary = [] ;
ary[ary.length] = new Point( 0, 6 ) ;
ary[ary.length] = new Point( 0, 5 ) ;
ary[ary.length] = new Point( 1, 5 ) ;
ary[ary.length] = new Point( 2, 5 ) ;
shapeJ.pictures[2] = ary  ;

ary = [] ;
ary[ary.length] = new Point( 1, 6 ) ;
ary[ary.length] = new Point( 0, 4 ) ;
ary[ary.length] = new Point( 0, 5 ) ;
ary[ary.length] = new Point( 0, 6 ) ;
shapeJ.pictures[3] = ary  ;

console.log(shapeJ);


class TypeI {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }
        if ( ++this.state > 1 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+3)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+2)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+3)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col = 4;
    state = 0;
}

class TypeJ {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }else if( this.state == 2 ){

        }else if( this.state == 3 ){

        }
        if ( ++this.state > 3 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col-1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col-1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col-1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect(this.col*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 2:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col-1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col-1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col-1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                break;
            case 3:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col-1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col = 5;
    state = 0;
}

class TypeL {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }else if( this.state == 2 ){

        }else if( this.state == 3 ){

        }
        if ( ++this.state > 3 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col-1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col-1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 2:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                break;
            case 3:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col-1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col = 4;
    state = 0;
}

class TypeO {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        
    }
    draw(){
        ctx.fillStyle = 'black'
        ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
        ctx.fillRect((this.col)*cellWidth,(this.row+1)*cellWidth, cellWidth, cellWidth)
        ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
        ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
    }
    row = 0;
    col = 4;
    state = 0;
}

class TypeS {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }
        if ( ++this.state > 1 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+2)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col =4;
    state = 0;
}

class TypeT {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }else if( this.state == 2 ){

        }else if( this.state == 3 ){

        }
        if ( ++this.state > 3 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+2)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 2:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+2)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 3:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col = 4;
    state = 0;
}

class TypeZ {
    moveRight(){
        this.col++
    }
    moveLeft(){
        this.col--
    }
    moveDown(){
        this.row++
    }
    rotation(){
        if( this.state == 0 ){

        }else if( this.state == 1 ){

        }
        if ( ++this.state > 1 ) {
            this.state = 0 ;
        }
    }
    draw(){
        switch( this.state ) {
            case 0:
                ctx.fillStyle = 'black'
                ctx.fillRect((this.col)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+2)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                break;
            case 1:
            ctx.fillStyle = 'black'
                ctx.fillRect((this.col+1)*cellWidth, (this.row)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col+1)*cellWidth, (this.row+1)*cellWidth, cellWidth, cellWidth)
                ctx.fillRect((this.col)*cellWidth, (this.row+2)*cellWidth, cellWidth, cellWidth)
                break;
        }
    }
    row = 0;
    col =4;
    state = 0;
}


//陣列(初始化)
for (let row = 0; row < 20; row++) {
    matrix[row] = [];

    for (let col = 0; col < 10; col++) {
        matrix[row][col] = 0; 
    }
}

//let typeI = new TypeI();
//typeI.draw();
let nowShape = shapeJ ;
nowShape.draw();

drawBackground();

document.addEventListener('keydown', 
	function(event) {
		switch(event.code) {
				  
			case 'ArrowDown':
				  //console.log('Down arrow key pressed.');
                  nowShape.moveDown();
				  break;
				  
			case 'ArrowLeft':
				  //console.log('Left arrow key pressed.');
				  nowShape.moveLeft();
				  break;
				  
			case 'ArrowRight':
				  //console.log('Right arrow key pressed.');
				  nowShape.moveRight();
				  break;

            case 'Space':
				  //console.log('Space key pressed.');
				  nowShape.rotation();
				  break;
                

        }
        clean();
        nowShape.draw();
        drawBackground();
    }
);

</script> 